<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="IE=edge,chrome=1"><meta name=google-site-verification content="WxZdzPANRFpehqogDMcTc9HLGXXDJy5If07MuUZvHho"><link rel=icon type=image/png href=../../../../favicon.png><link rel=stylesheet href=../../../../scss/styles.css><title>Bug story: Sorting by timestamp | adam-p</title></head><body><nav class="navbar navbar-expand-md navbar-light bg-light"><div class=container-fluid><a class=navbar-brand href=../../../../>adam-p
</a><button class=navbar-toggler type=button data-bs-toggle=collapse data-bs-target=#navbarNav aria-controls=navbarNav aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarNav><ul class=navbar-nav><li class=nav-item><a class=nav-link href=../../../../blog/>Blog</a></li><li class=nav-item><a class=nav-link href=../../../../inco/>In/Co</a></li><li class=nav-item><a class=nav-link href=../../../../projects/>Projects</a></li><li class=nav-item><a class=nav-link href=../../../../cv/>CV</a></li></ul></div></div></nav><div class=container-fluid><section><h1 class=title><a href=../../../../blog/2023/12/sort-by-timestamp/>Bug story: Sorting by timestamp</a></h1><h5 class=text-end>December 23, 2023</h5><div><article><p>While reviewing a co-worker&rsquo;s results-paging design I realized there was a bug in some paging code I wrote<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup> a few years ago. It&rsquo;s unlikely to manifest and kind of subtle, but I thought that describing it here might be useful to others writing such code (including my future self). It comes down to sorting by timestamp&mldr;</p><p>We&rsquo;ll start with a table like this:</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#00a8c8>CREATE</span> <span style=color:#00a8c8>TABLE</span> <span style=color:#111>item</span><span style=color:#111>(</span>
</span></span><span style=display:flex><span>  <span style=color:#111>id</span> <span style=color:#111>TEXT</span> <span style=color:#00a8c8>PRIMARY</span> <span style=color:#00a8c8>KEY</span> <span style=color:#00a8c8>DEFAULT</span> <span style=color:#111>generate_unique_id</span><span style=color:#111>(),</span>
</span></span><span style=display:flex><span>  <span style=color:#111>created</span> <span style=color:#111>TIMESTAMPTZ</span> <span style=color:#00a8c8>NOT</span> <span style=color:#00a8c8>NULL</span> <span style=color:#00a8c8>DEFAULT</span> <span style=color:#111>NOW</span><span style=color:#111>(),</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>-- plus other stuff not relevant to the story
</span></span></span></code></pre></div><p>Note that we don&rsquo;t have anything like a <code>SERIAL</code> column<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>, so <code>created</code> is our only option for traversing records chronologically.</p><p>Our clients will request pages of those items, persist them locally, and later check to see if there are new items. The paging query looks very generally like this:</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#75715e>-- last_known_id is input
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#00a8c8>SELECT</span> <span style=color:#f92672>*</span> <span style=color:#00a8c8>FROM</span> <span style=color:#111>item</span>
</span></span><span style=display:flex><span><span style=color:#00a8c8>WHERE</span> <span style=color:#111>created</span> <span style=color:#f92672>&gt;</span> <span style=color:#111>(</span><span style=color:#00a8c8>SELECT</span> <span style=color:#111>created</span> <span style=color:#00a8c8>FROM</span> <span style=color:#111>item</span> <span style=color:#00a8c8>WHERE</span> <span style=color:#111>id</span> <span style=color:#f92672>=</span> <span style=color:#111>last_known_id</span><span style=color:#111>)</span>
</span></span><span style=display:flex><span><span style=color:#00a8c8>ORDER</span> <span style=color:#00a8c8>BY</span> <span style=color:#111>created</span> <span style=color:#00a8c8>ASC</span>
</span></span><span style=display:flex><span><span style=color:#00a8c8>LIMIT</span> <span style=color:#ae81ff>10</span>
</span></span></code></pre></div><p>This approach would be fine if these properties were true (per user):</p><ol><li>The creation timestamp is unique</li><li>The creation timestamps are monotonically increasing</li></ol><p>When writing the code I unthinkingly took those to be the case. But when I took the time to think about it a few days ago, I quickly realized that they&rsquo;re bad assumptions. Let&rsquo;s look at some problems with them&mldr;</p><p>PostgreSQL&rsquo;s <a href=https://www.postgresql.org/docs/current/datatype-datetime.html#DATATYPE-DATETIME-TABLE>timestamp type</a> has microsecond resolution<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>. That&rsquo;s really small, but not infinitely so. It is surely theoretically possible to create more than one record with the same timestamp, even for the same user with cross-transaction serialization constraints. (It probably requires a transaction to begin and commit within a millisecond, but that&rsquo;s not enough to discount it.) This becomes trivially true if your DB operations don&rsquo;t have cross-transaction constraints.</p><p>From what I can find, Postgres does not provide a guarantee of stable sort for identical values. Based on what (little) I know about b-tree indexes, I think it&rsquo;s probably true for indexed values (unless some other index type gets used? unless the index gets rebuilt or shuffled?), but it&rsquo;s still not something that should be (sanely) relied on.</p><p>What happens to <code>now()</code> if the OS clock gets adjusted backwards (perhaps due to NTP update, assuming slew isn&rsquo;t used<sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup>)? If it goes backwards, then we lose monotonicity. But even if it doesn&rsquo;t update until a service restart, the restart can still be faster than the magnitude of the time change, so the clock can still effectively go backwards. Again, not monotonic.</p><p>If our DB server is in a (single writer, many readers) cluster, the same thing can happen if we fail over to a server that is behind the previous writer. <code>now()</code> again ends up in the past, until the time difference is caught up with.</p><p>So, our timestamp is not unique, not monotonically increasing, and we can&rsquo;t even trust that identical values will sort stably<sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup>. This means that our clients could miss items when paging.</p><p><strong>Monotonicity Failure Scenario</strong>: If the user has pulled down items to timestamp X and they manage to create a new item at timestamp X-1, they will never get it (at least until a full re-sync).</p><p><strong>Uniqueness Failure Scenario</strong>: If the user has two items at timestamp X and they retrieve a page where the last item on the page is the first of those items, the following page will skip the second of those items, because the query is only looking for items with a greater timestamp. (If we change the query to look for items with greater-than-or-equal timestamp, then we&rsquo;ll be getting duplicate items. Probably better, but still not good &ndash; especially if there&rsquo;s a whole page of duplicates that can never be escaped from.)</p><p>Again, these failures are improbable. In our case, a single user creating two items within the same microsecond, and then having those align on a page boundary, is unlikely. As is the possibility that our server clocks drift badly enough that backwards movement occurs.</p><p>But it could still happen! Which sucks!</p><p>I think that the right way to fix this is to add an ordering column. In our case it only needs to be ordered per user, but it&rsquo;s probably easiest to just use a <code>BIGSERIAL</code> and order the whole table. We would then use that column rather than <code>created</code> when sorting. It will provide the properties of uniqueness and monotonicity that we need.</p><p>There are a few takeaways here:</p><ol><li>Thinking about time <a href=https://gist.github.com/timvisee/fcda9bbdff88d45cc9061606b4b923ca>is hard</a>.</li><li>Try your best to recognize your bedrock, implicit assumptions about things. Which is also hard, since they&rsquo;re mostly subconscious.</li><li>Review other people&rsquo;s code (and have your own reviewed, of course). It forces you to think broader, deeper, and different, and can help you with your own code.</li></ol><hr><p>There is discussion of this post on Hacker News <a href="https://news.ycombinator.com/item?id=38745637">here</a>.</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>The implementation was part of a big change that got squashed &ndash; a practice I am having doubts about &ndash; so I don&rsquo;t know for sure if I wrote it. It was years ago! But I certainly reviewed it, and didn&rsquo;t know better, so I&rsquo;m still taking the blame here.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>For reasons. We need a random primary key.&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>A <a href="https://news.ycombinator.com/item?id=38747686">commenter on HN</a> pointed out that the resolution of the timestamp might be coarser than microsecond if the resolution of the service providing time to Postgres is coarser. <em>Probably</em> it&rsquo;s not coarser, but it&rsquo;s another thing to not take for granted.&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p>If slew <em>is</em> used, then that might increase the likelihood that identical timestamps occur, as time effectively slows down while the correction is made.&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5><p>An <a href="https://news.ycombinator.com/item?id=38759601">HN commenter said</a>: &ldquo;I found it to be a generally useful rule to never <code>ORDER BY created</code> but instead <code>ORDER BY created,id</code> instead to achieve stable sorting.&rdquo; Which, yeah, is great advice. It&rsquo;s probably great advice for any &ldquo;sort by timestamp&rdquo; scenario &ndash; you just need a another unique value to use as the secondary sort, even if it&rsquo;s not itself usefully sortable.&#160;<a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></article></div></section><hr><aside><p><h5>984 Words</h5></p><p>Last Update:
<time datetime="Wed Dec 120 127:121:18 27270 -0500" class=text-muted>December 27, 2023</time><br><a href=https://github.com/adam-p/adam-p.github.com/commits/master/content/blog/2023-12-23-sort-by-timestamp.md>See revision history</a></p><p><br>Previous: <a class=previous href=../../../../blog/2023/06/parenting-tips/>Inexpert Parenting Tips</a></p></aside><footer class=text-end><small>© 2025 Adam Pritchard</small></footer></div><script src=../../../../node_modules/bootstrap/dist/js/bootstrap.js></script></body></html>