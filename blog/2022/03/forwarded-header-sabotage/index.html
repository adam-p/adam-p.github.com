<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="IE=edge,chrome=1"><meta name=google-site-verification content="WxZdzPANRFpehqogDMcTc9HLGXXDJy5If07MuUZvHho"><link rel=icon type=image/png href=../../../../favicon.png><link rel=stylesheet href=../../../../scss/styles.css><title>Forwarded Header Sabotage | adam-p</title></head><body><nav class="navbar navbar-expand-md navbar-light bg-light"><div class=container-fluid><a class=navbar-brand href=../../../../>adam-p
</a><button class=navbar-toggler type=button data-bs-toggle=collapse data-bs-target=#navbarNav aria-controls=navbarNav aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarNav><ul class=navbar-nav><li class=nav-item><a class=nav-link href=../../../../blog/>Blog</a></li><li class=nav-item><a class=nav-link href=../../../../inco/>In/Co</a></li><li class=nav-item><a class=nav-link href=../../../../projects/>Projects</a></li><li class=nav-item><a class=nav-link href=../../../../cv/>CV</a></li></ul></div></div></nav><div class=container-fluid><section><h1 class=title><a href=../../../../blog/2022/03/forwarded-header-sabotage/>Forwarded Header Sabotage</a></h1><h5 class=text-end>March 30, 2022</h5><div><article><p><a href=../../../../blog/2022/03/x-forwarded-for/>We all know by now</a> that the leftmost values in the <code>X-Forwarded-For</code> header can be spoofed and only the rightmost IPs &ndash; added by your own reverse proxies &ndash; can be trusted. The <code>Forwarded</code> header (<a href=https://datatracker.ietf.org/doc/html/rfc7239>RFC 7239</a>, 2014) has that same problem, and a new one: If the header is parsed correctly, an attacker can <em>sabotage the whole header</em>.</p><p>Let&rsquo;s take a quick trip to understanding how that can happen and how complicated <code>Forwarded</code> parsing can get. (Think about how you&rsquo;d parse the header as we go.)</p><h2 id=syntax><a class=heading-anchor href=#syntax>##
</a>Syntax</h2><p>A simple <code>Forwarded</code> header might look like this:</p><pre tabindex=0><code>Forwarded: for=1.1.1.1, For=2.2.2.2
</code></pre><p>Here&rsquo;s what a header looks like with an IPv6 value:</p><pre tabindex=0><code>Forwarded: for=1.1.1.1, FOR=&#34;[2001:db8:cafe::17]&#34;
</code></pre><p>Colons and square brackets are <a href=https://datatracker.ietf.org/doc/html/rfc7230#section-3.2.6>not allowed in a &ldquo;token&rdquo;</a>, so the IPv6 address needs to be quoted. But that means we could have:</p><pre tabindex=0><code>Forwarded: host=&#34;with,comma=equals;semicolon&#34;;for=1.1.1.1
</code></pre><p>So now you can&rsquo;t just split by comma &ndash; you need to be aware of quoted strings as well.</p><p>But characters can also be escaped, so this is also legal:</p><pre tabindex=0><code>Forwarded: ext=&#34;escaped\&#34;quote&#34;;for=1.1.1.1
</code></pre><p>The blessed semicolon-separated parameter names in an entry are &ldquo;for&rdquo;, &ldquo;by&rdquo;, &ldquo;host&rdquo;, and &ldquo;proto&rdquo; (case-insensitive). There is allowance for &ldquo;extensions&rdquo; using other tokens.</p><p>Some more legal things:</p><ul><li>Anything can be escaped, including backslashes: <code>\\</code>. So don&rsquo;t just delete all them all.</li><li>Any amount of whitespace around the commas and semicolons.</li><li>There can be multiple instances of the header, and they must be considered a single list, top to bottom.</li></ul><p>And some illegal things:</p><ul><li>Can&rsquo;t have whitespace around the equal sign.</li><li>Can&rsquo;t have disallowed characters in parameter names (and not quotable).</li><li>Can&rsquo;t have disallowed characters in a parameter value, if not quoted. (Which mean, for example, that an unquoted IPv6 address is illegal.)</li><li>IPv6 addresses must have square brackets.</li><li>Backslash escaping is only allowed in quoted strings.</li></ul><p>There is only one single library I&rsquo;ve found that actually correctly parses the header: <a href=https://github.com/lpinca/forwarded-parse>github.com/lpinca/forwarded-parse</a>.<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup> Everything else just does what you were probably thinking after the first couple of steps above:</p><ol><li>Split by comma.</li><li>Trim whitespace.</li><li>Split by semicolon.</li><li>Trim the quotes off the value.</li><li>Done.</li></ol><p>Hilariously, this half-assed, RFC-violating parsing is resistant to sabotage and proper parsing is not.</p><h2 id=sabotagehttpswwwyoutubecomwatchvz5rrzdiu1ue><a class=heading-anchor href=#sabotagehttpswwwyoutubecomwatchvz5rrzdiu1ue>##
</a><a href="https://www.youtube.com/watch?v=z5rRZdiu1UE">Sabotage!</a></h2><p>The <code>Forwarded</code> header is unique. It is the only header that:</p><ol><li>Has untrusted values at the start and trusted values at the end.</li><li>Is official and specified.</li></ol><p>This combination leads to its susceptibility to sabotage, where the whole header &ndash; including the trusted part &ndash; needs to be discarded because of chicanery in the untrusted part.</p><p>The RFC doesn&rsquo;t (that I can find) provide any special instructions about salvaging the rest of the header if a single entry (&ldquo;forwarded-element&rdquo;) has a syntax error. So, in theory, the whole header needs to be thrown if a spoofer adds, say, <code>f*r=</code> instead of <code>for=</code>.</p><p>The sabotage is even more fun with an unclosed double-quote:</p><pre tabindex=0><code>Forwarded: for=&#34;1.1.1.1, for=2.2.2.2, for=3.3.3.3
</code></pre><p>It&rsquo;s illegal to have an unclosed quote, so the whole thing is immediately garbage. But even if you wanted to salvage the header&mldr; Where do you close the quote? What do you salvage and discard?</p><h2 id=why-is-x-forwarded-for-not-sabotage-able><a class=heading-anchor href=#why-is-x-forwarded-for-not-sabotage-able>##
</a>Why is <code>X-Forwarded-For</code> not sabotage-able?</h2><p>Because there&rsquo;s no spec! People just split by comma, trim, and that&rsquo;s it. Your trusted reverse proxy will add <code>", 1.1.1.1"</code> and you don&rsquo;t really need to care about what comes before that. (Unless you want the leftmost-ish value, but then you&rsquo;re in the danger zone regardless.)</p><h2 id=mitigations><a class=heading-anchor href=#mitigations>##
</a>Mitigations</h2><p>&ldquo;Half-assed, RFC-violating parsing&rdquo; is the most obvious. If you&rsquo;re using a rightmost-ish value, you should know if your reverse proxies are going to be quoting things, escaping, etc. &ndash; and they probably aren&rsquo;t. So do a simple comma-splitting and throw away the stuff on the left.</p><p>Doing simple splitting means that you could end up with total garbage in your leftmost values &ndash; from spoofing or from valid-but-complicated values. You could probably make your parser more-complex-but-still-not-RFC-compliant by trying to handle quotes and escaping, without discarding everything in the case of bad data. Perhaps your deviation rule could be &ldquo;no commas allowed in quotes or escaped; they always signal a new entry&rdquo;. Or just don&rsquo;t use a leftmost value.</p><p>(Note that differences in parsing at different points &ndash; reverse proxies, server, etc. &ndash; could result in <a href=../../../../blog/2022/03/x-forwarded-for/#x-forwarded-for-parser-mismatch>parser mismatch vulnerabilities</a>.)</p><p>At the reverse proxy level, the obvious mitigation is to discard any existing <code>Forwarded</code> headers and start fresh, so there are only trusted, well-formed values. If you don&rsquo;t like the idea of discarding potentially valuable forensic information, maybe your reverse proxy could move the previous header value into some new <code>X-</code> header before starting fresh.</p><p>A variation on unconditionally discarding the <code>Forwarded</code> is to check for validity and, if it fails, discard or replace with <code>for=unknown</code> (which is also per spec). (I <a href=https://github.com/lpinca/forwarded-parse/issues/6>asked lpinca</a> and this is what he prefers.)</p><p>Another possibility is to have your reverse proxy not discard the existing <code>Forwarded</code> headers but to add a new one. <em>Maybe</em> the separate headers could be sanely interpreted separately. But this violates <a href=https://datatracker.ietf.org/doc/html/rfc2616#section-4.2>RFC 2616</a>, which says &ldquo;It MUST be possible to combine the multiple header fields into one &ldquo;field-name: field-value&rdquo; pair, without changing the semantics of the message&rdquo;.</p><p>So, I can&rsquo;t see how it&rsquo;s possible to adhere to the spec <em>and</em> retain the existing header value without falling victim to sabotage.</p><h2 id=conclusion><a class=heading-anchor href=#conclusion>##
</a>Conclusion</h2><p>I wrote a half-assed, RFC-violating <code>Forwarded</code> parser. Then I decided I wanted it to be &ldquo;correct&rdquo; and started looking for better implementations.</p><p>Along the way I found an <a href=https://forum.nginx.org/read.php?29,275880>Nginx forum conversation</a> from 2017 about adding <code>Forwarded</code> support. That conversation is interesting and brought the sabotage potential to my attention, but there&rsquo;s no resolution. It just kind of trails off into hopelessness. (Interestingly, there was strong resistance to discarding the header and thereby losing information.)</p><p>Because my <code>Forwarded</code> parser is in <a href=https://github.com/realclientip/realclientip-go>a project</a> that I am hoping will be a reference implementation for getting the &ldquo;real&rdquo; client IP, I really wanted the parser itself to be a reference implementation. But, as disappointing as it is, it seems like being spec-compliant is the wrong move. I also can&rsquo;t assume that a user of the library has the ability to tweak their reverse proxy handling of <code>Forwarded</code> (I mean, I could state it as a requirement for use of the library, but that&rsquo;s limiting and error-prone). Documenting the shortcomings seems about as good as it gets.</p><p>(Now I have to figure out how to summarize this in the MDN <code>Forwarded</code> page update that <a href=https://github.com/mdn/content/pull/13838#issuecomment-1071933350>I&rsquo;m on the hook for</a>&mldr;)</p><h2 id=addendum><a class=heading-anchor href=#addendum>##
</a>Addendum</h2><p>[2022-04-03: Added this section.]</p><p><a href=https://github.com/dmolesUC>David Moles</a> <a href=https://github.com/golang/go/issues/30963#issuecomment-1085057745>pointed out</a> that Nginx <a href=https://www.nginx.com/resources/wiki/start/topics/examples/forwarded/>has instructions</a> for enabling <code>Fowarded</code> handling. Part of that is this amazing regex that should be used for validation:</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-no-highlight data-lang=no-highlight><span style=display:flex><span>^(,[ \t]*)*([!#$%&amp;&#39;*+.^_`|~0-9A-Za-z-]+=([!#$%&amp;&#39;*+.^_`|~0-9A-Za-z-]+|&#34;([\t \x21\x23-\x5B\x5D-\x7E\x80-\xFF]|\\[\t \x21-\x7E\x80-\xFF])*&#34;))?(;([!#$%&amp;&#39;*+.^_`|~0-9A-Za-z-]+=([!#$%&amp;&#39;*+.^_`|~0-9A-Za-z-]+|&#34;([\t \x21\x23-\x5B\x5D-\x7E\x80-\xFF]|\\[\t \x21-\x7E\x80-\xFF])*&#34;))?)*([ \t]*,([ \t]*([!#$%&amp;&#39;*+.^_`|~0-9A-Za-z-]+=([!#$%&amp;&#39;*+.^_`|~0-9A-Za-z-]+|&#34;([\t \x21\x23-\x5B\x5D-\x7E\x80-\xFF]|\\[\t \x21-\x7E\x80-\xFF])*&#34;))?(;([!#$%&amp;&#39;*+.^_`|~0-9A-Za-z-]+=([!#$%&amp;&#39;*+.^_`|~0-9A-Za-z-]+|&#34;([\t \x21\x23-\x5B\x5D-\x7E\x80-\xFF]|\\[\t \x21-\x7E\x80-\xFF])*&#34;))?)*)?)*$
</span></span></code></pre></div><p>David and Tim McCormack (via email) both suggested that maybe the <code>Forwarded</code> header could be parsed backwards. I initially didn&rsquo;t think that would be much better that just splitting by comma an parsing each pice, but I&rsquo;ve come around to the idea. It allows stricter RFC adherence (quoted commas) while still allowing salvaging of rightmost good values.</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>Seriously, big kudos to lpinca.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></article></div></section><hr><aside><p><h5>1,176 Words</h5></p><p>Last Update:
<time datetime="Sun Apr 40 47:46:68 3030 -0400" class=text-muted>April 03, 2022</time><br><a href=https://github.com/adam-p/adam-p.github.com/commits/master/content//blog/2022-03-30-forwarded-header-sabotage>See revision history</a></p><p>Next: <a class=next href=../../../../blog/2022/10/password-plus-plus/>More Than a Password</a><br>Previous: <a class=previous href=../../../../blog/2022/03/strip-ipv6-zone/>Should you strip the IPv6 zone?</a></p></aside><footer class=text-end><small>Â© 2025 Adam Pritchard</small></footer></div><script src=../../../../node_modules/bootstrap/dist/js/bootstrap.js></script></body></html>